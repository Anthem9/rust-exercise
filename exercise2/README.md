Rust语言的所有权系统（ownership system）和引用规则是它内存安全性的核心。这种系统确保了在编译时检测数据竞争和内存泄露，而无需运行时的垃圾收集。以下是关于所有权，不可变引用，可变引用的一些主要规则和特性：

1. **所有权（Ownership）**
   - Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。
   - 值在任一时刻有且只有一个所有者。
   - 当所有者（变量）离开作用域，这个值将被丢弃。

2. **不可变引用（Immutable References）**
   - 不可变引用用于读取数据，但不更改数据。
   - 你可以一次拥有任意数量的不可变引用，但所有不可变引用必须在最后一次可变引用之前创建。
   - 在最后一个不可变引用后，你不能创建更多的可变引用。

3. **可变引用（Mutable References）**
   - 可变引用用于更改数据。
   - 一次只能有一个可变引用（在特定范围内）。
   - 你不能同时拥有可变和不可变引用。换言之，如果有一个可变引用，那么不能有不可变引用，反之亦然。

这些规则是为了在编译期间防止数据竞争。数据竞争发生在以下三个行为同时发生时：
1. 两个或多个指针同时访问同一数据。
2. 至少有一个指针被用来写入数据。
3. 数据访问没有被同步。

Rust 通过上述所有权和引用规则，在编译时期阻止这种情况的发生，从而保证了内存安全。

**例1：所有权转移**

```Rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{}, world!", s1); // 这行会引起错误
}
```
在这个例子中，`s1`的所有权被移动到`s2`，因此你不能再访问`s1`。这就是所谓的所有权规则。

**例2：不可变引用**

```Rust
fn main() {
    let s = String::from("hello");
    let r1 = &s;
    let r2 = &s;

    println!("{}, {}", r1, r2); // 这行是正确的，因为 r1 和 r2 都是不可变引用。
}
```

在这个例子中，我们可以创建多个不可变引用。这是不可变引用的特性。

**例3：不可变和可变引用的冲突**

```Rust
fn main() {
    let mut s = String::from("hello");
    let r1 = &s;
    let r2 = &mut s;

    println!("{}, {}", r1, r2); // 这行会引起错误
}
```

在这个例子中，我们试图创建一个不可变引用和一个可变引用。根据规则，这是不允许的，所以这段代码会引起错误。